{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LLMGT Game Sampling Game Sampling : Sample payoff matrices with structural constraints. Build Games Build Games : Define payoff logic and dominance conditions. Prompt Utilities Prompt Utilities : Build prompt inputs from config files and templates. General Utilities Path resolution : Resolves path in project.","title":"Home"},{"location":"#llmgt","text":"","title":"LLMGT"},{"location":"#game-sampling","text":"Game Sampling : Sample payoff matrices with structural constraints.","title":"Game Sampling"},{"location":"#build-games","text":"Build Games : Define payoff logic and dominance conditions.","title":"Build Games"},{"location":"#prompt-utilities","text":"Prompt Utilities : Build prompt inputs from config files and templates.","title":"Prompt Utilities"},{"location":"#general-utilities","text":"Path resolution : Resolves path in project.","title":"General Utilities"},{"location":"game_build/","text":"Game Building We generate structured 2x2 games for evaluation and experimentation. Core Functions sample_payoffs() Samples a list of four random payoff values between 1 and 10. def sample_payoffs() -> list[int]: return [random.randint(1, 10) for _ in range(4)] sample_fn(condition) Samples payoff tuples until a given condition is satisfied. def sample_fn(condition: Callable[[int, int, int, int], bool]): while True: a = sample_payoffs() if condition(*a): return tuple(a) cond_p1_dominant_top(x1, x2, x3, x4) Returns True if Player 1 strictly prefers the top row. def cond_p1_dominant_top(x1, x2, x3, x4): return x1 > x3 and x2 > x4 Player 1 prefers the top row if: x1 > x3 and x2 > x4 cond_p1_dominant_bot(x1, x2, x3, x4) Returns True if Player 1 strictly prefers the bot row. def cond_p1_dominant_top(x1, x2, x3, x4): return x3 > x1 and x4 > x2 Player 1 prefers the bot row if: x3 > x1 and x4 > x2 cond_p2_dominant_lef(y1, y2, y3, y4) Returns True if Player 2 strictly prefers the left column. def cond_p2_dominant_left(y1, y2, y3, y4): return y1 > y2 and y3 > y4 Player 2 prefers the left column if: y1 > y2 and y3 > y4 cond_p2_dominant_right(y1, y2, y3, y4) Returns True if Player 2 strictly prefers the right column. def cond_p2_dominant_right(y1, y2, y3, y4): return y2 > y1 and y4 > y1 Player 2 prefers the left column if: y2 > y1 and y4 > y1 Configuration The CONFIG_GAMES dictionary defines structural presets for sampling 2x2 games. Player dominance conditions Structural descriptors Expected Nash equilibrium (NE) locations { \"p1_cond\": cond_p1_dominant_top, \"p2_cond\": cond_p2_dominant_left, \"structure\": { \"dominance\": { \"p1\": \"top\", \"p2\": \"left\" } }, \"nash_locations\": [\"TL\"] }","title":"Build Games"},{"location":"game_build/#game-building","text":"We generate structured 2x2 games for evaluation and experimentation.","title":"Game Building"},{"location":"game_build/#core-functions","text":"","title":"Core Functions"},{"location":"game_build/#sample_payoffs","text":"Samples a list of four random payoff values between 1 and 10. def sample_payoffs() -> list[int]: return [random.randint(1, 10) for _ in range(4)]","title":"sample_payoffs()"},{"location":"game_build/#sample_fncondition","text":"Samples payoff tuples until a given condition is satisfied. def sample_fn(condition: Callable[[int, int, int, int], bool]): while True: a = sample_payoffs() if condition(*a): return tuple(a)","title":"sample_fn(condition)"},{"location":"game_build/#cond_p1_dominant_topx1-x2-x3-x4","text":"Returns True if Player 1 strictly prefers the top row. def cond_p1_dominant_top(x1, x2, x3, x4): return x1 > x3 and x2 > x4 Player 1 prefers the top row if: x1 > x3 and x2 > x4","title":"cond_p1_dominant_top(x1, x2, x3, x4)"},{"location":"game_build/#cond_p1_dominant_botx1-x2-x3-x4","text":"Returns True if Player 1 strictly prefers the bot row. def cond_p1_dominant_top(x1, x2, x3, x4): return x3 > x1 and x4 > x2 Player 1 prefers the bot row if: x3 > x1 and x4 > x2","title":"cond_p1_dominant_bot(x1, x2, x3, x4)"},{"location":"game_build/#cond_p2_dominant_lefy1-y2-y3-y4","text":"Returns True if Player 2 strictly prefers the left column. def cond_p2_dominant_left(y1, y2, y3, y4): return y1 > y2 and y3 > y4 Player 2 prefers the left column if: y1 > y2 and y3 > y4","title":"cond_p2_dominant_lef(y1, y2, y3, y4)"},{"location":"game_build/#cond_p2_dominant_righty1-y2-y3-y4","text":"Returns True if Player 2 strictly prefers the right column. def cond_p2_dominant_right(y1, y2, y3, y4): return y2 > y1 and y4 > y1 Player 2 prefers the left column if: y2 > y1 and y4 > y1","title":"cond_p2_dominant_right(y1, y2, y3, y4)"},{"location":"game_build/#configuration","text":"The CONFIG_GAMES dictionary defines structural presets for sampling 2x2 games. Player dominance conditions Structural descriptors Expected Nash equilibrium (NE) locations { \"p1_cond\": cond_p1_dominant_top, \"p2_cond\": cond_p2_dominant_left, \"structure\": { \"dominance\": { \"p1\": \"top\", \"p2\": \"left\" } }, \"nash_locations\": [\"TL\"] }","title":"Configuration"},{"location":"game_sample/","text":"Game Sampling We sample generated 2x2 games. Core Functions build_labelled_payoffs(p1, p2) Labels Player 1 and Player 2's payoffs using the standard [\"TL\", \"TR\", \"BL\", \"BR\"] format. def build_labelled_payoffs(p1: tuple[int, int, int, int], p2: tuple[int, int, int, int]) -> Tuple[dict, dict]: labels = [\"TL\", \"TR\", \"BL\", \"BR\"] return dict(zip(labels, p1)), dict(zip(labels, p2)) Returns Two dictionaries mapping quadrant to payoffs for P1 and P2. build_matrix_fn(data) Constructs a 2x2 matrix from a labeled dictionary. def build_matrix_fn(data: dict) -> list[list]: return [[data[\"TL\"], data[\"TR\"]], [data[\"BL\"], data[\"BR\"]]] Returns A 2D list structured as a payoff matrix. Full game wrapping","title":"Game Sampling"},{"location":"game_sample/#game-sampling","text":"We sample generated 2x2 games.","title":"Game Sampling"},{"location":"game_sample/#core-functions","text":"","title":"Core Functions"},{"location":"game_sample/#build_labelled_payoffsp1-p2","text":"Labels Player 1 and Player 2's payoffs using the standard [\"TL\", \"TR\", \"BL\", \"BR\"] format. def build_labelled_payoffs(p1: tuple[int, int, int, int], p2: tuple[int, int, int, int]) -> Tuple[dict, dict]: labels = [\"TL\", \"TR\", \"BL\", \"BR\"] return dict(zip(labels, p1)), dict(zip(labels, p2)) Returns Two dictionaries mapping quadrant to payoffs for P1 and P2.","title":"build_labelled_payoffs(p1, p2)"},{"location":"game_sample/#build_matrix_fndata","text":"Constructs a 2x2 matrix from a labeled dictionary. def build_matrix_fn(data: dict) -> list[list]: return [[data[\"TL\"], data[\"TR\"]], [data[\"BL\"], data[\"BR\"]]] Returns A 2D list structured as a payoff matrix.","title":"build_matrix_fn(data)"},{"location":"game_sample/#full-game-wrapping","text":"","title":"Full game wrapping"},{"location":"paths/","text":"Path Resolution enrich_paths enrich_paths ( config : dict ) -> dict Attach output JSON paths (per message key) to the config. Uses the 'predictions' stage directory under pipeline_data/stages/. get_data_path get_data_path ( subdir : str , name : str = '' ) -> Path Return a path under pipeline_data/ / . Parameters: Name Type Description Default subdir str Subdirectory inside pipeline_data/ required name str Optional file or subfolder name '' Returns: Type Description Path Resolved path to the requested file or folder get_pipeline_data_dir get_pipeline_data_dir () -> Path Return the path to the pipeline_data/ directory. get_project_root get_project_root () -> Path Return the root path of the project repository. get_stage_path get_stage_path ( stage : str , name : str = '' ) -> Path Return a path under pipeline_data/stages/ / . Parameters: Name Type Description Default stage str Name of the stage (e.g., \"games\", \"prompts\", \"predictions\") required name str Optional filename or subdirectory '' Returns: Type Description Path Resolved path to the stage-specific target","title":"Path Resolution"},{"location":"paths/#path-resolution","text":"","title":"Path Resolution"},{"location":"paths/#llmgt.utils.paths.enrich_paths","text":"enrich_paths ( config : dict ) -> dict Attach output JSON paths (per message key) to the config. Uses the 'predictions' stage directory under pipeline_data/stages/.","title":"enrich_paths"},{"location":"paths/#llmgt.utils.paths.get_data_path","text":"get_data_path ( subdir : str , name : str = '' ) -> Path Return a path under pipeline_data/ / . Parameters: Name Type Description Default subdir str Subdirectory inside pipeline_data/ required name str Optional file or subfolder name '' Returns: Type Description Path Resolved path to the requested file or folder","title":"get_data_path"},{"location":"paths/#llmgt.utils.paths.get_pipeline_data_dir","text":"get_pipeline_data_dir () -> Path Return the path to the pipeline_data/ directory.","title":"get_pipeline_data_dir"},{"location":"paths/#llmgt.utils.paths.get_project_root","text":"get_project_root () -> Path Return the root path of the project repository.","title":"get_project_root"},{"location":"paths/#llmgt.utils.paths.get_stage_path","text":"get_stage_path ( stage : str , name : str = '' ) -> Path Return a path under pipeline_data/stages/ / . Parameters: Name Type Description Default stage str Name of the stage (e.g., \"games\", \"prompts\", \"predictions\") required name str Optional filename or subdirectory '' Returns: Type Description Path Resolved path to the stage-specific target","title":"get_stage_path"},{"location":"prompts/","text":"Prompt Utilities load_and_transform_dataset load_and_transform_dataset ( input_path : Path , prompt_fn : Callable ) -> Dataset Load a dataset from JSON and apply a transformation function. Parameters: Name Type Description Default input_path Path Path to the input JSON file. required prompt_fn Callable Function that transforms each example. required Returns: Type Description Dataset A HuggingFace Dataset with transformed examples. load_prompt_config_and_dirs load_prompt_config_and_dirs ( config_name : str , style : str , cot_style : str = 'COT' , config_dir : str = 'prompt_config' ) -> tuple [ dict , Path , Path ] Load a prompt config and resolve template and CoT directories. Parameters: Name Type Description Default config_name str Name of the config file (e.g. \"prompts.json\"). required style str User template subfolder name. required cot_style str CoT subfolder name (default \"COT\"). 'COT' config_dir str Base config folder name (default \"prompt_config\"). 'prompt_config' Returns: Type Description tuple [ dict , Path , Path ] A tuple of (config dict, template path, cot path).","title":"Prompt Utilities"},{"location":"prompts/#prompt-utilities","text":"","title":"Prompt Utilities"},{"location":"prompts/#llmgt.prompts.prompts.load_and_transform_dataset","text":"load_and_transform_dataset ( input_path : Path , prompt_fn : Callable ) -> Dataset Load a dataset from JSON and apply a transformation function. Parameters: Name Type Description Default input_path Path Path to the input JSON file. required prompt_fn Callable Function that transforms each example. required Returns: Type Description Dataset A HuggingFace Dataset with transformed examples.","title":"load_and_transform_dataset"},{"location":"prompts/#llmgt.prompts.prompts.load_prompt_config_and_dirs","text":"load_prompt_config_and_dirs ( config_name : str , style : str , cot_style : str = 'COT' , config_dir : str = 'prompt_config' ) -> tuple [ dict , Path , Path ] Load a prompt config and resolve template and CoT directories. Parameters: Name Type Description Default config_name str Name of the config file (e.g. \"prompts.json\"). required style str User template subfolder name. required cot_style str CoT subfolder name (default \"COT\"). 'COT' config_dir str Base config folder name (default \"prompt_config\"). 'prompt_config' Returns: Type Description tuple [ dict , Path , Path ] A tuple of (config dict, template path, cot path).","title":"load_prompt_config_and_dirs"}]}